\section{Vorwort}
Die Dokumentation orientiert sich an der Reihenfolge der Aufgaben im Bewertungsschema.
Alle Testprogramme funktionieren und die Hardwareansteuerung wurde umgesetzt.



\section{Simulatoren}
Entwickelt wurde ein Simulator für den PIC16F84:
Also eine Software, die das Verhalten dieses Mikrocontrollers nachbildet,
um PIC16F84 Assemblerprogramme auf einem x86 Computer in einer grafischen Oberfläche Ausführen zu können.
Hierbei wurde nicht das genaue Verhalten implementiert, mit allen internen Zuständen,
sondern das Ergebnis nach außen.

\paragraph{Vor- \& Nachteile}



\section{Funktionsweise}

\subsection{Gewählte Technologien}
Die Software ist als Webanwendung umgesetzt.
Es gibt also zwei Teile, in die die Anwendung unterteilt werden kann:
Front- und Back-End.
Das Back-End ist in der Programmiersprache C\# geschrieben, mit der \char`\~90~\% des Codes geschrieben wurde,
die Logik im Front-End in JavaScript.
Zum Beschreiben der grafischen Oberfläche wird HTML verwendet.
Es wird das Blazor\urlfootnote{https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor} Web-Framework verwendet.
Der Grund für die Wahl von Blazor ist,
diese für uns unbekannte Technologie beim Entwickeln dieses Projekts kennenzulernen. 


\subsection{Einlesen von Programmen}
Das Einlesen der LST-Dateien funktioniert über einen Parser im Front-End,
der mit dem Parsergenerator Tree-sitter\urlfootnote{https://tree-sitter.github.io/tree-sitter/} erstellt wurde.
Tree-sitter generiert aus einer LR(1) Grammatik C-Code für einen Parser,
der zu WebAssembly compiliert wird, ein Bytecode-Standard der W3C zum Ausführen von Programmen innerhalb des Webbrowsers.
Die Anbindung an die JS-API des Browsers funktioniert über eine 
Bibliothek\urlfootnote{https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_web} des Tree-sitter Projekts.
Das ist der Grund dafür, dass dieser Teil der Logik im Front-End ist.

\js[Auszug der Grammatik für LST-Dateien (\texttt{tree-sitter-pic/grammar.js}).]{./listings/grammatik.js}

Der Parser baut einen konkreten Syntaxbaum auf.
Durch Traversieren des Baumes wird der Text (zum Anzeigen mit Syntaxhervorhebung) in HTML-Elemente verpackt,
weiter werden durch das Traversieren die relevanten Informationen für den Simulator extrahiert:

\begin{itemize}
    \item Position im Programmspeicher
    \item Opcode 
    \item Zeilennummer im Quellcode (für Breakpoints)
\end{itemize}

Diese Informationen werden an das Back-End (den C\# Teil) übergeben,
der damit ein \texttt{Pic}-Objekt initialisiert, das Hauptobjekt des Simulators.

\subsection{\texttt{Pic}-Objekt}
Das Hauptobjekt im Simulator im vom Typt \texttt{Pic}.
Es enthält alle simulierten Elemente des PIC16F84,
wie z. B. den Haupt-, Programmspeicher und das W-Register. 


\subsection{Befehle}

\subsubsection{Befehlsdecodierung}
Die Befehlsdecodierung funktioniert über das Interpretieren der geparsten Opcode-Zeichenketten als Zahlen.
Die Zahlen werden wieder in Strings mit Binärdarstellung der Zahlen umgewandelt,
für einen Vergleich vom Stringanfang um den Befehl zu bestimmen.

\cs[Logik zum dekodieren der Opcode-Strings (\texttt{Simulation/InstructionDecoder.cs}).]{./listings/instruction-decoder.cs}

\subsubsection{Befehlsmodellierung}
Befehle werden durch Klassen modelliert (z. B. \texttt{ADDWF}).
Sie erben alle von der abstrakten Klasse \texttt{Instruction}.

\paragraph{Programmspeicher}
Der Programmspeicher ist ein Array vom Typ \texttt{Instruction},
der die alle dekodierten Befehle in Reihenfolge der LST-Datei einhält. 

\texttt{Instruction}-Objekte haben eine Referenz auf ihr zugehöriges \texttt{Pic}-Objekt
und verändern durch Aufrufen ihrer \texttt{Execute}-Methode den Zustand von diesem,
beispielsweise die Flags im Statusregister.

\cs[\texttt{Execute}-Methode vom MOVLW-Befehl (\texttt{Simulation/Instructions/LiteralInstructions/MOVLW.cs})]{./listings/movlw.cs}

\paragraph{Befehlsabarbeitung}
Die Befehlsabarbeitung funktioniert über eine Schleife,
die mit dem Programmzähler (als Index) den aktuellen Befehl aus dem Programmspeicher-Array holt.


\subsection{Hauptspeicher}
Der Hautspeicher ist als Klasse \texttt{Memory} umgesetzt,
die ein Array vom Typ \texttt{uint} für die Regsiter enthält.
Das Lesen und Schreiben in den Hautspeicher funktioniert über spezielle Methoden: \texttt{ReadRegister} und \texttt{WriteRegsiter}.
In diesen Methoden werden Bedingungen wie die Adressspiegelung für spezielle Regsiter umgesetzt.

\cs[Teil der Switch-Case in der \texttt{WriteRegister}-Methode]{./listings/switch-case-memory.cs}

Weiter gibt es zwei extra Methoden für das Lesen und Schreiben die das \texttt{RP0}-Bit beachten. 


\subsection{Programmzähler}
Der Programmzähler wird in der Variable \texttt{\_programCounter} in \texttt{Pic} gespeichert.
Das Schreiben funktioniert über einen Setter,
der immer das Pcl-Regsiter aktualisiert.
Falls in das Pcl-Register geschrieben wird,
wird die \_programCounter Variable aktualisiert (von der \texttt{Memory}-Klasse aus).

\paragraph{PCLATH}
Der Wert im PCLATH-Regsiter wird bei jedem \texttt{GOTO} und \texttt{CALL} Befehl beachtet.
Hier wird in der \texttt{Execute}-Methode die \texttt{\_programCounter} Variable aktualisiert.
Die Beachtung für z. B. ein \texttt{ADDWF} wird auch in der \texttt{Memory}-Klasse umgesetzt,
wenn in das PCL-Regsiter geschrieben wird. 


\subsection{Timerfunktion}


\subsection{Interrupts}


\subsection{Sleep}


\subsection{Watchdog}


\subsection{EEPROM}


\subsection{I/O Ausgangslatch}


\subsection{Hardwareanbindung}



\subsection{Grafische Oberfläche}

\subsubsection{Bedienung}

\subsubsection{Breakpoints}



\section{Zusammenfassung}

\subsection{Ergebnis}


\subsection{Persönliches Fazit (Valerio Cocco)}

